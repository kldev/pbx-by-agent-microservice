/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * PBX Identity API (via Gateway)
 * OpenAPI spec version: 1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
	MutationFunction,
	QueryClient,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";

import type {
	ApiErrorResponse,
	CreateTeamRequest,
	GetByGidRequest,
	TeamListFilter,
	TeamResponse,
	TeamResponsePagedResult,
	UpdateTeamRequest,
} from "../../models";

import { customFetch } from "../../../custom-fetch";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
	T,
>() => T extends Y ? 1 : 2
	? A
	: B;

type WritableKeys<T> = {
	[P in keyof T]-?: IfEquals<
		{ [Q in P]: T[P] },
		{ -readonly [Q in P]: T[P] },
		P
	>;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
	k: infer I,
) => void
	? I
	: never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
	? {
			[P in keyof Writable<T>]: T[P] extends object
				? NonReadonly<NonNullable<T[P]>>
				: T[P];
		}
	: DistributeReadOnlyOverUnions<T>;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export type getTeamListResponse200 = {
	data: TeamResponsePagedResult;
	status: 200;
};

export type getTeamListResponse400 = {
	data: ApiErrorResponse;
	status: 400;
};

export type getTeamListResponseSuccess = getTeamListResponse200 & {
	headers: Headers;
};
export type getTeamListResponseError = getTeamListResponse400 & {
	headers: Headers;
};

export type getTeamListResponse =
	| getTeamListResponseSuccess
	| getTeamListResponseError;

export const getGetTeamListUrl = () => {
	return `/api/identity/teams/list`;
};

export const getTeamList = async (
	teamListFilter: NonReadonly<TeamListFilter>,
	options?: RequestInit,
): Promise<getTeamListResponse> => {
	return customFetch<getTeamListResponse>(getGetTeamListUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(teamListFilter),
	});
};

export const getGetTeamListMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getTeamList>>,
		TError,
		{ data: NonReadonly<TeamListFilter> },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getTeamList>>,
	TError,
	{ data: NonReadonly<TeamListFilter> },
	TContext
> => {
	const mutationKey = ["getTeamList"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getTeamList>>,
		{ data: NonReadonly<TeamListFilter> }
	> = (props) => {
		const { data } = props ?? {};

		return getTeamList(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetTeamListMutationResult = NonNullable<
	Awaited<ReturnType<typeof getTeamList>>
>;
export type GetTeamListMutationBody = NonReadonly<TeamListFilter>;
export type GetTeamListMutationError = ApiErrorResponse;

export const useGetTeamList = <TError = ApiErrorResponse, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getTeamList>>,
			TError,
			{ data: NonReadonly<TeamListFilter> },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getTeamList>>,
	TError,
	{ data: NonReadonly<TeamListFilter> },
	TContext
> => {
	const mutationOptions = getGetTeamListMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
export type getTeamResponse200 = {
	data: TeamResponse;
	status: 200;
};

export type getTeamResponse404 = {
	data: ApiErrorResponse;
	status: 404;
};

export type getTeamResponseSuccess = getTeamResponse200 & {
	headers: Headers;
};
export type getTeamResponseError = getTeamResponse404 & {
	headers: Headers;
};

export type getTeamResponse = getTeamResponseSuccess | getTeamResponseError;

export const getGetTeamUrl = () => {
	return `/api/identity/teams/by-gid`;
};

export const getTeam = async (
	getByGidRequest: GetByGidRequest,
	options?: RequestInit,
): Promise<getTeamResponse> => {
	return customFetch<getTeamResponse>(getGetTeamUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(getByGidRequest),
	});
};

export const getGetTeamMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getTeam>>,
		TError,
		{ data: GetByGidRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getTeam>>,
	TError,
	{ data: GetByGidRequest },
	TContext
> => {
	const mutationKey = ["getTeam"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getTeam>>,
		{ data: GetByGidRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getTeam(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetTeamMutationResult = NonNullable<
	Awaited<ReturnType<typeof getTeam>>
>;
export type GetTeamMutationBody = GetByGidRequest;
export type GetTeamMutationError = ApiErrorResponse;

export const useGetTeam = <TError = ApiErrorResponse, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getTeam>>,
			TError,
			{ data: GetByGidRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getTeam>>,
	TError,
	{ data: GetByGidRequest },
	TContext
> => {
	const mutationOptions = getGetTeamMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
export type createTeamResponse201 = {
	data: TeamResponse;
	status: 201;
};

export type createTeamResponse400 = {
	data: ApiErrorResponse;
	status: 400;
};

export type createTeamResponseSuccess = createTeamResponse201 & {
	headers: Headers;
};
export type createTeamResponseError = createTeamResponse400 & {
	headers: Headers;
};

export type createTeamResponse =
	| createTeamResponseSuccess
	| createTeamResponseError;

export const getCreateTeamUrl = () => {
	return `/api/identity/teams`;
};

export const createTeam = async (
	createTeamRequest: CreateTeamRequest,
	options?: RequestInit,
): Promise<createTeamResponse> => {
	return customFetch<createTeamResponse>(getCreateTeamUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createTeamRequest),
	});
};

export const getCreateTeamMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createTeam>>,
		TError,
		{ data: CreateTeamRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createTeam>>,
	TError,
	{ data: CreateTeamRequest },
	TContext
> => {
	const mutationKey = ["createTeam"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createTeam>>,
		{ data: CreateTeamRequest }
	> = (props) => {
		const { data } = props ?? {};

		return createTeam(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateTeamMutationResult = NonNullable<
	Awaited<ReturnType<typeof createTeam>>
>;
export type CreateTeamMutationBody = CreateTeamRequest;
export type CreateTeamMutationError = ApiErrorResponse;

export const useCreateTeam = <TError = ApiErrorResponse, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof createTeam>>,
			TError,
			{ data: CreateTeamRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof createTeam>>,
	TError,
	{ data: CreateTeamRequest },
	TContext
> => {
	const mutationOptions = getCreateTeamMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
export type updateTeamResponse200 = {
	data: TeamResponse;
	status: 200;
};

export type updateTeamResponse400 = {
	data: ApiErrorResponse;
	status: 400;
};

export type updateTeamResponse404 = {
	data: ApiErrorResponse;
	status: 404;
};

export type updateTeamResponseSuccess = updateTeamResponse200 & {
	headers: Headers;
};
export type updateTeamResponseError = (
	| updateTeamResponse400
	| updateTeamResponse404
) & {
	headers: Headers;
};

export type updateTeamResponse =
	| updateTeamResponseSuccess
	| updateTeamResponseError;

export const getUpdateTeamUrl = (gid: string) => {
	return `/api/identity/teams/${gid}`;
};

export const updateTeam = async (
	gid: string,
	updateTeamRequest: UpdateTeamRequest,
	options?: RequestInit,
): Promise<updateTeamResponse> => {
	return customFetch<updateTeamResponse>(getUpdateTeamUrl(gid), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateTeamRequest),
	});
};

export const getUpdateTeamMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateTeam>>,
		TError,
		{ gid: string; data: UpdateTeamRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateTeam>>,
	TError,
	{ gid: string; data: UpdateTeamRequest },
	TContext
> => {
	const mutationKey = ["updateTeam"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateTeam>>,
		{ gid: string; data: UpdateTeamRequest }
	> = (props) => {
		const { gid, data } = props ?? {};

		return updateTeam(gid, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateTeamMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateTeam>>
>;
export type UpdateTeamMutationBody = UpdateTeamRequest;
export type UpdateTeamMutationError = ApiErrorResponse;

export const useUpdateTeam = <TError = ApiErrorResponse, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof updateTeam>>,
			TError,
			{ gid: string; data: UpdateTeamRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof updateTeam>>,
	TError,
	{ gid: string; data: UpdateTeamRequest },
	TContext
> => {
	const mutationOptions = getUpdateTeamMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
export type deleteTeamResponse200 = {
	data: boolean;
	status: 200;
};

export type deleteTeamResponse404 = {
	data: ApiErrorResponse;
	status: 404;
};

export type deleteTeamResponseSuccess = deleteTeamResponse200 & {
	headers: Headers;
};
export type deleteTeamResponseError = deleteTeamResponse404 & {
	headers: Headers;
};

export type deleteTeamResponse =
	| deleteTeamResponseSuccess
	| deleteTeamResponseError;

export const getDeleteTeamUrl = (gid: string) => {
	return `/api/identity/teams/${gid}`;
};

export const deleteTeam = async (
	gid: string,
	options?: RequestInit,
): Promise<deleteTeamResponse> => {
	return customFetch<deleteTeamResponse>(getDeleteTeamUrl(gid), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteTeamMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteTeam>>,
		TError,
		{ gid: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteTeam>>,
	TError,
	{ gid: string },
	TContext
> => {
	const mutationKey = ["deleteTeam"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteTeam>>,
		{ gid: string }
	> = (props) => {
		const { gid } = props ?? {};

		return deleteTeam(gid, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteTeamMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteTeam>>
>;

export type DeleteTeamMutationError = ApiErrorResponse;

export const useDeleteTeam = <TError = ApiErrorResponse, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof deleteTeam>>,
			TError,
			{ gid: string },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof deleteTeam>>,
	TError,
	{ gid: string },
	TContext
> => {
	const mutationOptions = getDeleteTeamMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
