/**
 * Generated by orval v7.17.0 
 * Do not edit manually.
 * PBX Rcp API (via Gateway)
 * OpenAPI spec version: 1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
	MutationFunction,
	QueryClient,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";

import type {
	ApiErrorResponse,
	GetByGidRequest,
	GetPeriodRequest,
	MonthlyEntryResponse,
	PeriodSummaryResponse,
	ReturnForCorrectionRequest,
} from "../../models";

import { customFetch } from "../../../custom-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Lista wpis贸w do rozliczenia
 */
export type getPayrollPeriodEntriesResponse200 = {
	data: PeriodSummaryResponse;
	status: 200;
};

export type getPayrollPeriodEntriesResponseSuccess =
	getPayrollPeriodEntriesResponse200 & {
		headers: Headers;
	};

export type getPayrollPeriodEntriesResponse =
	getPayrollPeriodEntriesResponseSuccess;

export const getGetPayrollPeriodEntriesUrl = () => {
	return `/api/rcp/payroll/period`;
};

export const getPayrollPeriodEntries = async (
	getPeriodRequest: GetPeriodRequest,
	options?: RequestInit,
): Promise<getPayrollPeriodEntriesResponse> => {
	return customFetch<getPayrollPeriodEntriesResponse>(
		getGetPayrollPeriodEntriesUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(getPeriodRequest),
		},
	);
};

export const getGetPayrollPeriodEntriesMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getPayrollPeriodEntries>>,
		TError,
		{ data: GetPeriodRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getPayrollPeriodEntries>>,
	TError,
	{ data: GetPeriodRequest },
	TContext
> => {
	const mutationKey = ["getPayrollPeriodEntries"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getPayrollPeriodEntries>>,
		{ data: GetPeriodRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getPayrollPeriodEntries(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetPayrollPeriodEntriesMutationResult = NonNullable<
	Awaited<ReturnType<typeof getPayrollPeriodEntries>>
>;
export type GetPayrollPeriodEntriesMutationBody = GetPeriodRequest;
export type GetPayrollPeriodEntriesMutationError = unknown;

/**
 * @summary Lista wpis贸w do rozliczenia
 */
export const useGetPayrollPeriodEntries = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getPayrollPeriodEntries>>,
			TError,
			{ data: GetPeriodRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getPayrollPeriodEntries>>,
	TError,
	{ data: GetPeriodRequest },
	TContext
> => {
	const mutationOptions = getGetPayrollPeriodEntriesMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Pobierz wpis do rozliczenia
 */
export type getPayrollEntryResponse200 = {
	data: MonthlyEntryResponse;
	status: 200;
};

export type getPayrollEntryResponse404 = {
	data: ApiErrorResponse;
	status: 404;
};

export type getPayrollEntryResponseSuccess = getPayrollEntryResponse200 & {
	headers: Headers;
};
export type getPayrollEntryResponseError = getPayrollEntryResponse404 & {
	headers: Headers;
};

export type getPayrollEntryResponse =
	| getPayrollEntryResponseSuccess
	| getPayrollEntryResponseError;

export const getGetPayrollEntryUrl = () => {
	return `/api/rcp/payroll/entry`;
};

export const getPayrollEntry = async (
	getByGidRequest: GetByGidRequest,
	options?: RequestInit,
): Promise<getPayrollEntryResponse> => {
	return customFetch<getPayrollEntryResponse>(getGetPayrollEntryUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(getByGidRequest),
	});
};

export const getGetPayrollEntryMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getPayrollEntry>>,
		TError,
		{ data: GetByGidRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getPayrollEntry>>,
	TError,
	{ data: GetByGidRequest },
	TContext
> => {
	const mutationKey = ["getPayrollEntry"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getPayrollEntry>>,
		{ data: GetByGidRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getPayrollEntry(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetPayrollEntryMutationResult = NonNullable<
	Awaited<ReturnType<typeof getPayrollEntry>>
>;
export type GetPayrollEntryMutationBody = GetByGidRequest;
export type GetPayrollEntryMutationError = ApiErrorResponse;

/**
 * @summary Pobierz wpis do rozliczenia
 */
export const useGetPayrollEntry = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getPayrollEntry>>,
			TError,
			{ data: GetByGidRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getPayrollEntry>>,
	TError,
	{ data: GetByGidRequest },
	TContext
> => {
	const mutationOptions = getGetPayrollEntryMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Zwr贸 do poprawy
 */
export type returnForCorrectionResponse200 = {
	data: MonthlyEntryResponse;
	status: 200;
};

export type returnForCorrectionResponse400 = {
	data: ApiErrorResponse;
	status: 400;
};

export type returnForCorrectionResponse404 = {
	data: ApiErrorResponse;
	status: 404;
};

export type returnForCorrectionResponseSuccess =
	returnForCorrectionResponse200 & {
		headers: Headers;
	};
export type returnForCorrectionResponseError = (
	| returnForCorrectionResponse400
	| returnForCorrectionResponse404
) & {
	headers: Headers;
};

export type returnForCorrectionResponse =
	| returnForCorrectionResponseSuccess
	| returnForCorrectionResponseError;

export const getReturnForCorrectionUrl = () => {
	return `/api/rcp/payroll/return`;
};

export const returnForCorrection = async (
	returnForCorrectionRequest: ReturnForCorrectionRequest,
	options?: RequestInit,
): Promise<returnForCorrectionResponse> => {
	return customFetch<returnForCorrectionResponse>(getReturnForCorrectionUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(returnForCorrectionRequest),
	});
};

export const getReturnForCorrectionMutationOptions = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof returnForCorrection>>,
		TError,
		{ data: ReturnForCorrectionRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof returnForCorrection>>,
	TError,
	{ data: ReturnForCorrectionRequest },
	TContext
> => {
	const mutationKey = ["returnForCorrection"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof returnForCorrection>>,
		{ data: ReturnForCorrectionRequest }
	> = (props) => {
		const { data } = props ?? {};

		return returnForCorrection(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReturnForCorrectionMutationResult = NonNullable<
	Awaited<ReturnType<typeof returnForCorrection>>
>;
export type ReturnForCorrectionMutationBody = ReturnForCorrectionRequest;
export type ReturnForCorrectionMutationError = ApiErrorResponse;

/**
 * @summary Zwr贸 do poprawy
 */
export const useReturnForCorrection = <
	TError = ApiErrorResponse,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof returnForCorrection>>,
			TError,
			{ data: ReturnForCorrectionRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof returnForCorrection>>,
	TError,
	{ data: ReturnForCorrectionRequest },
	TContext
> => {
	const mutationOptions = getReturnForCorrectionMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Eksportuj do Excel
 */
export type exportToExcelResponse200 = {
	data: string;
	status: 200;
};

export type exportToExcelResponseSuccess = exportToExcelResponse200 & {
	headers: Headers;
};

export type exportToExcelResponse = exportToExcelResponseSuccess;

export const getExportToExcelUrl = () => {
	return `/api/rcp/payroll/export`;
};

export const exportToExcel = async (
	getPeriodRequest: GetPeriodRequest,
	options?: RequestInit,
): Promise<exportToExcelResponse> => {
	return customFetch<exportToExcelResponse>(getExportToExcelUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(getPeriodRequest),
	});
};

export const getExportToExcelMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof exportToExcel>>,
		TError,
		{ data: GetPeriodRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof exportToExcel>>,
	TError,
	{ data: GetPeriodRequest },
	TContext
> => {
	const mutationKey = ["exportToExcel"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof exportToExcel>>,
		{ data: GetPeriodRequest }
	> = (props) => {
		const { data } = props ?? {};

		return exportToExcel(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ExportToExcelMutationResult = NonNullable<
	Awaited<ReturnType<typeof exportToExcel>>
>;
export type ExportToExcelMutationBody = GetPeriodRequest;
export type ExportToExcelMutationError = unknown;

/**
 * @summary Eksportuj do Excel
 */
export const useExportToExcel = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof exportToExcel>>,
			TError,
			{ data: GetPeriodRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof exportToExcel>>,
	TError,
	{ data: GetPeriodRequest },
	TContext
> => {
	const mutationOptions = getExportToExcelMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
