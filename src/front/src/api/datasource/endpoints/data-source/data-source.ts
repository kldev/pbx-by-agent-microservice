/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * PBX DataSource API (via Gateway)
 * OpenAPI spec version: 1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
	MutationFunction,
	QueryClient,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";

import type {
	DataSourceTypeInfo,
	EmptyRequest,
	PickerDataResponse,
	ResolveRequest,
	SearchRequest,
	SubordinatesRequest,
	SuggestionsRequest,
} from "../../models";

import { customFetch } from "../../../custom-fetch";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get suggestions - 25 records sorted by domain logic
 */
export type getSuggestionsResponse200 = {
	data: PickerDataResponse;
	status: 200;
};

export type getSuggestionsResponseSuccess = getSuggestionsResponse200 & {
	headers: Headers;
};

export type getSuggestionsResponse = getSuggestionsResponseSuccess;

export const getGetSuggestionsUrl = () => {
	return `/api/datasource/suggestions`;
};

export const getSuggestions = async (
	suggestionsRequest: SuggestionsRequest,
	options?: RequestInit,
): Promise<getSuggestionsResponse> => {
	return customFetch<getSuggestionsResponse>(getGetSuggestionsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(suggestionsRequest),
	});
};

export const getGetSuggestionsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getSuggestions>>,
		TError,
		{ data: SuggestionsRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getSuggestions>>,
	TError,
	{ data: SuggestionsRequest },
	TContext
> => {
	const mutationKey = ["getSuggestions"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getSuggestions>>,
		{ data: SuggestionsRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getSuggestions(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetSuggestionsMutationResult = NonNullable<
	Awaited<ReturnType<typeof getSuggestions>>
>;
export type GetSuggestionsMutationBody = SuggestionsRequest;
export type GetSuggestionsMutationError = unknown;

export const useGetSuggestions = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getSuggestions>>,
			TError,
			{ data: SuggestionsRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getSuggestions>>,
	TError,
	{ data: SuggestionsRequest },
	TContext
> => {
	const mutationOptions = getGetSuggestionsMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * Search by query phrase
 */
export type searchDataResponse200 = {
	data: PickerDataResponse;
	status: 200;
};

export type searchDataResponseSuccess = searchDataResponse200 & {
	headers: Headers;
};

export type searchDataResponse = searchDataResponseSuccess;

export const getSearchDataUrl = () => {
	return `/api/datasource/search`;
};

export const searchData = async (
	searchRequest: SearchRequest,
	options?: RequestInit,
): Promise<searchDataResponse> => {
	return customFetch<searchDataResponse>(getSearchDataUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(searchRequest),
	});
};

export const getSearchDataMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof searchData>>,
		TError,
		{ data: SearchRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof searchData>>,
	TError,
	{ data: SearchRequest },
	TContext
> => {
	const mutationKey = ["searchData"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof searchData>>,
		{ data: SearchRequest }
	> = (props) => {
		const { data } = props ?? {};

		return searchData(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SearchDataMutationResult = NonNullable<
	Awaited<ReturnType<typeof searchData>>
>;
export type SearchDataMutationBody = SearchRequest;
export type SearchDataMutationError = unknown;

export const useSearchData = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof searchData>>,
			TError,
			{ data: SearchRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof searchData>>,
	TError,
	{ data: SearchRequest },
	TContext
> => {
	const mutationOptions = getSearchDataMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * Resolve GID/ID for Tag/Prefill component
 */
export type resolveDataResponse200 = {
	data: PickerDataResponse;
	status: 200;
};

export type resolveDataResponseSuccess = resolveDataResponse200 & {
	headers: Headers;
};

export type resolveDataResponse = resolveDataResponseSuccess;

export const getResolveDataUrl = () => {
	return `/api/datasource/resolve`;
};

export const resolveData = async (
	resolveRequest: ResolveRequest,
	options?: RequestInit,
): Promise<resolveDataResponse> => {
	return customFetch<resolveDataResponse>(getResolveDataUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(resolveRequest),
	});
};

export const getResolveDataMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof resolveData>>,
		TError,
		{ data: ResolveRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof resolveData>>,
	TError,
	{ data: ResolveRequest },
	TContext
> => {
	const mutationKey = ["resolveData"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof resolveData>>,
		{ data: ResolveRequest }
	> = (props) => {
		const { data } = props ?? {};

		return resolveData(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ResolveDataMutationResult = NonNullable<
	Awaited<ReturnType<typeof resolveData>>
>;
export type ResolveDataMutationBody = ResolveRequest;
export type ResolveDataMutationError = unknown;

export const useResolveData = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof resolveData>>,
			TError,
			{ data: ResolveRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof resolveData>>,
	TError,
	{ data: ResolveRequest },
	TContext
> => {
	const mutationOptions = getResolveDataMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * Get available data source types
 */
export type getDataSourceTypesResponse200 = {
	data: DataSourceTypeInfo[];
	status: 200;
};

export type getDataSourceTypesResponseSuccess =
	getDataSourceTypesResponse200 & {
		headers: Headers;
	};

export type getDataSourceTypesResponse = getDataSourceTypesResponseSuccess;

export const getGetDataSourceTypesUrl = () => {
	return `/api/datasource/types`;
};

export const getDataSourceTypes = async (
	emptyRequest: EmptyRequest,
	options?: RequestInit,
): Promise<getDataSourceTypesResponse> => {
	return customFetch<getDataSourceTypesResponse>(getGetDataSourceTypesUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(emptyRequest),
	});
};

export const getGetDataSourceTypesMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getDataSourceTypes>>,
		TError,
		{ data: EmptyRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getDataSourceTypes>>,
	TError,
	{ data: EmptyRequest },
	TContext
> => {
	const mutationKey = ["getDataSourceTypes"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getDataSourceTypes>>,
		{ data: EmptyRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getDataSourceTypes(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetDataSourceTypesMutationResult = NonNullable<
	Awaited<ReturnType<typeof getDataSourceTypes>>
>;
export type GetDataSourceTypesMutationBody = EmptyRequest;
export type GetDataSourceTypesMutationError = unknown;

export const useGetDataSourceTypes = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getDataSourceTypes>>,
			TError,
			{ data: EmptyRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getDataSourceTypes>>,
	TError,
	{ data: EmptyRequest },
	TContext
> => {
	const mutationOptions = getGetDataSourceTypesMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
/**
 * Get subordinates for a supervisor (used by RCP)
 */
export type getSubordinatesResponse200 = {
	data: PickerDataResponse;
	status: 200;
};

export type getSubordinatesResponseSuccess = getSubordinatesResponse200 & {
	headers: Headers;
};

export type getSubordinatesResponse = getSubordinatesResponseSuccess;

export const getGetSubordinatesUrl = () => {
	return `/api/datasource/subordinates`;
};

export const getSubordinates = async (
	subordinatesRequest: SubordinatesRequest,
	options?: RequestInit,
): Promise<getSubordinatesResponse> => {
	return customFetch<getSubordinatesResponse>(getGetSubordinatesUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(subordinatesRequest),
	});
};

export const getGetSubordinatesMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof getSubordinates>>,
		TError,
		{ data: SubordinatesRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof getSubordinates>>,
	TError,
	{ data: SubordinatesRequest },
	TContext
> => {
	const mutationKey = ["getSubordinates"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof getSubordinates>>,
		{ data: SubordinatesRequest }
	> = (props) => {
		const { data } = props ?? {};

		return getSubordinates(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GetSubordinatesMutationResult = NonNullable<
	Awaited<ReturnType<typeof getSubordinates>>
>;
export type GetSubordinatesMutationBody = SubordinatesRequest;
export type GetSubordinatesMutationError = unknown;

export const useGetSubordinates = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof getSubordinates>>,
			TError,
			{ data: SubordinatesRequest },
			TContext
		>;
		request?: SecondParameter<typeof customFetch>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof getSubordinates>>,
	TError,
	{ data: SubordinatesRequest },
	TContext
> => {
	const mutationOptions = getGetSubordinatesMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
